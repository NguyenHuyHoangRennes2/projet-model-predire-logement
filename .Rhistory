"Catégorie (A–G)", "kWh/an", "kg/an", "Nom du quartier"),
`Source` = rep("Ouest-France Immo (web scraping)", 8)
),
caption = "Tableau 1 : Description des variables"
)
seuil <-  quantile(annonces$Loyer_TTC ,probs = seq(0, 1, 0.25))
annonces$Loyer_Groupe <- cut(annonces$Loyer_TTC , breaks = seuil , include.lowest = TRUE)
table(annonces$label_eco)
annonces <-annonces %>%filter(label_eco !="NC") # levels il reste toujours meme si le nombre d'effective =0
annonces$label_eco <- droplevels(annonces$label_eco)
levels(annonces$label_eco)[levels(annonces$label_eco) %in% c("G","A","B" ,"C")] <-"C+"
levels(annonces$label_eco)[levels(annonces$label_eco) %in% c("E","F")] <-"E-"
levels(annonces$label_eco)[] <-levels(annonces$label_eco)[1:3]
levels(annonces$label_eco)
idx <- which(annonces$label_eco == "C+")
annonces$label_eco <- as.numeric(annonces$label_eco)
annonces$label_eco[idx]
table(annonces$label_eco)
#install.packages("fastDummies")
library(fastDummies)
annonces <- annonces%>% mutate(Quartiers = sub("Quartiers " , "" , Quartiers))
annonces$Quartiers <- factor(annonces$Quartiers)
annonces <- dummy_cols(annonces, select_columns = "Quartiers")
library(tidyverse)
annonces <- annonces %>% mutate(Pièces = ifelse(is.na(Pièces) , 1 ,Pièces))
annonces <- dplyr::select(annonces, -Pièce)
annonces <- annonces %>%
group_by(label_eco) %>%
mutate(
kWh   = ifelse(is.na(kWh),   mean(kWh,   na.rm = TRUE), kWh),
kgCO2 = ifelse(is.na(kgCO2), mean(kgCO2, na.rm = TRUE), kgCO2)
) %>%
ungroup()
# Remplacer les charges manquantes par la moyenne du groupe de loyer (arrondi à 2 décimales)
annonces <- annonces %>%
group_by(Loyer_Groupe) %>%
mutate(
Charges = ifelse(
is.na(Charges),
round(mean(Charges, na.rm = TRUE), 2),
Charges
)
) %>%
ungroup()
anyNA(annonces)
summary_stats <- annonces %>%
select(Loyer_TTC, Surface, Charges, Pièces , label_eco, kWh, kgCO2)
install.packages("tidyverse")
install.packages("tidyverse")
knitr::opts_chunk$set(cache = F,
message = FALSE,   # ↩ cache les messages (library, etc.)
warning = FALSE)
options("install.lock"=FALSE) #Désactiver le verrouillage d’installation des packages
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) ## configure le chemin du dossier automatiquement
#install.packages("tidyverse")
summary_stats <- annonces %>% select(Loyer_TTC, Surface, Charges, Pièces , label_eco, kWh, kgCO2)
knitr::opts_chunk$set(cache = F,
message = FALSE,   # ↩ cache les messages (library, etc.)
warning = FALSE)
options("install.lock"=FALSE) #Désactiver le verrouillage d’installation des packages
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) ## configure le chemin du dossier automatiquement
library("tidyverse")
annonces <- read.csv("annonces.csv" , sep=",")
annonces <- annonces[, c("Loyer", "Surface.habitable", "Dont.charges",
"Pièces" , "Pièce", "label_eco", "kWh.m...an",
"kgCO2.m...an", "Quartiers")]
annonces <- annonces %>%
rename(
Loyer_TTC = Loyer,
Surface   = `Surface.habitable`,
Charges   = `Dont.charges`,
kWh       =  kWh.m...an,
kgCO2     = `kgCO2.m...an`
)
annonces$label_eco <- factor(annonces$label_eco)
head(annonces,5)
knitr::kable(
data.frame(
`Code de la série` = c("prix_TCC", "Surface", "Charges", "Pieces",
"label_eco", "kWh", "kgCO2", "Quartiers"),
`Définition` = c("Loyer mensuel tout compris",
"Surface habitable du logement",
"Montant des charges mensuelles",
"Nombre de pièces du logement",
"Classe énergétique du logement",
"Consommation énergétique annuelle",
"Émissions annuelles de CO2",
"Secteur géographique du logement"),
`Unité` = c("Euros", "m²", "Euros", "Nombre",
"Catégorie (A–G)", "kWh/an", "kg/an", "Nom du quartier"),
`Source` = rep("Ouest-France Immo (web scraping)", 8)
),
caption = "Tableau 1 : Description des variables"
)
seuil <-  quantile(annonces$Loyer_TTC ,probs = seq(0, 1, 0.25))
annonces$Loyer_Groupe <- cut(annonces$Loyer_TTC , breaks = seuil , include.lowest = TRUE)
table(annonces$label_eco)
annonces <-annonces %>%filter(label_eco !="NC") # levels il reste toujours meme si le nombre d'effective =0
annonces$label_eco <- droplevels(annonces$label_eco)
levels(annonces$label_eco)[levels(annonces$label_eco) %in% c("G","A","B" ,"C")] <-"C+"
levels(annonces$label_eco)[levels(annonces$label_eco) %in% c("E","F")] <-"E-"
levels(annonces$label_eco)[] <-levels(annonces$label_eco)[1:3]
levels(annonces$label_eco)
idx <- which(annonces$label_eco == "C+")
annonces$label_eco <- as.numeric(annonces$label_eco)
annonces$label_eco[idx]
table(annonces$label_eco)
#install.packages("fastDummies")
library(fastDummies)
annonces <- annonces%>% mutate(Quartiers = sub("Quartiers " , "" , Quartiers))
annonces$Quartiers <- factor(annonces$Quartiers)
annonces <- dummy_cols(annonces, select_columns = "Quartiers")
library(tidyverse)
annonces <- annonces %>% mutate(Pièces = ifelse(is.na(Pièces) , 1 ,Pièces))
annonces <- dplyr::select(annonces, -Pièce)
annonces <- annonces %>%
group_by(label_eco) %>%
mutate(
kWh   = ifelse(is.na(kWh),   mean(kWh,   na.rm = TRUE), kWh),
kgCO2 = ifelse(is.na(kgCO2), mean(kgCO2, na.rm = TRUE), kgCO2)
) %>%
ungroup()
# Remplacer les charges manquantes par la moyenne du groupe de loyer (arrondi à 2 décimales)
annonces <- annonces %>%
group_by(Loyer_Groupe) %>%
mutate(
Charges = ifelse(
is.na(Charges),
round(mean(Charges, na.rm = TRUE), 2),
Charges
)
) %>%
ungroup()
anyNA(annonces)
#install.packages("tidyverse")
summary_stats <- annonces %>% select(Loyer_TTC, Surface, Charges, Pièces , label_eco, kWh, kgCO2)
result <- data.frame(
Var    = colnames(summary_stats),
Min    = sapply(summary_stats, min, na.rm = TRUE),
Q1     = sapply(summary_stats, quantile, 0.25, na.rm = TRUE),
Median = sapply(summary_stats, median, na.rm = TRUE),
Mean   = sapply(summary_stats, mean, na.rm = TRUE),
Q3     = sapply(summary_stats, quantile, 0.75, na.rm = TRUE),
Max    = sapply(summary_stats, max, na.rm = TRUE),
SD     = sapply(summary_stats, sd, na.rm = TRUE)
)
knitr::kable(result, caption = "Tableau 2 : Statistiques descriptives des variables quantitatives")
knitr::opts_chunk$set(cache = F,
message = FALSE,   # ↩ cache les messages (library, etc.)
warning = FALSE)
options("install.lock"=FALSE) #Désactiver le verrouillage d’installation des packages
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) ## configure le chemin du dossier automatiquement
library("tidyverse")
annonces <- read.csv("annonces.csv" , sep=",")
annonces <- annonces[, c("Loyer", "Surface.habitable", "Dont.charges",
"Pièces" , "Pièce", "label_eco", "kWh.m...an",
"kgCO2.m...an", "Quartiers")]
annonces <- annonces %>%
rename(
Loyer_TTC = Loyer,
Surface   = `Surface.habitable`,
Charges   = `Dont.charges`,
kWh       =  kWh.m...an,
kgCO2     = `kgCO2.m...an`
)
annonces$label_eco <- factor(annonces$label_eco)
head(annonces,5)
knitr::kable(
data.frame(
`Code de la série` = c("prix_TCC", "Surface", "Charges", "Pieces",
"label_eco", "kWh", "kgCO2", "Quartiers"),
`Définition` = c("Loyer mensuel tout compris",
"Surface habitable du logement",
"Montant des charges mensuelles",
"Nombre de pièces du logement",
"Classe énergétique du logement",
"Consommation énergétique annuelle",
"Émissions annuelles de CO2",
"Secteur géographique du logement"),
`Unité` = c("Euros", "m²", "Euros", "Nombre",
"Catégorie (A–G)", "kWh/an", "kg/an", "Nom du quartier"),
`Source` = rep("Ouest-France Immo (web scraping)", 8)
),
caption = "Tableau 1 : Description des variables"
)
seuil <-  quantile(annonces$Loyer_TTC ,probs = seq(0, 1, 0.25))
annonces$Loyer_Groupe <- cut(annonces$Loyer_TTC , breaks = seuil , include.lowest = TRUE)
table(annonces$label_eco)
annonces <-annonces %>%filter(label_eco !="NC") # levels il reste toujours meme si le nombre d'effective =0
annonces$label_eco <- droplevels(annonces$label_eco)
levels(annonces$label_eco)[levels(annonces$label_eco) %in% c("G","A","B" ,"C")] <-"C+"
levels(annonces$label_eco)[levels(annonces$label_eco) %in% c("E","F")] <-"E-"
levels(annonces$label_eco)[] <-levels(annonces$label_eco)[1:3]
levels(annonces$label_eco)
idx <- which(annonces$label_eco == "C+")
annonces$label_eco <- as.numeric(annonces$label_eco)
annonces$label_eco[idx]
table(annonces$label_eco)
#install.packages("fastDummies")
library(fastDummies)
annonces <- annonces%>% mutate(Quartiers = sub("Quartiers " , "" , Quartiers))
annonces$Quartiers <- factor(annonces$Quartiers)
annonces <- dummy_cols(annonces, select_columns = "Quartiers")
library(tidyverse)
annonces <- annonces %>% mutate(Pièces = ifelse(is.na(Pièces) , 1 ,Pièces))
annonces <- dplyr::select(annonces, -Pièce)
annonces <- annonces %>%
group_by(label_eco) %>%
mutate(
kWh   = ifelse(is.na(kWh),   mean(kWh,   na.rm = TRUE), kWh),
kgCO2 = ifelse(is.na(kgCO2), mean(kgCO2, na.rm = TRUE), kgCO2)
) %>%
ungroup()
# Remplacer les charges manquantes par la moyenne du groupe de loyer (arrondi à 2 décimales)
annonces <- annonces %>%
group_by(Loyer_Groupe) %>%
mutate(
Charges = ifelse(
is.na(Charges),
round(mean(Charges, na.rm = TRUE), 2),
Charges
)
) %>%
ungroup()
anyNA(annonces)
#install.packages("tidyverse")
summary_stats <- annonces %>% select(Loyer_TTC, Surface, Charges, Pièces , label_eco, kWh, kgCO2)
result <- data.frame(
Var    = colnames(summary_stats),
Min    = sapply(summary_stats, min, na.rm = TRUE),
Q1     = sapply(summary_stats, quantile, 0.25, na.rm = TRUE),
Median = sapply(summary_stats, median, na.rm = TRUE),
Mean   = sapply(summary_stats, mean, na.rm = TRUE),
Q3     = sapply(summary_stats, quantile, 0.75, na.rm = TRUE),
Max    = sapply(summary_stats, max, na.rm = TRUE),
SD     = sapply(summary_stats, sd, na.rm = TRUE)
)
knitr::kable(result, caption = "Tableau 2 : Statistiques descriptives des variables quantitatives")
library(knitr)
library(htmltools)
library(kableExtra)
# ------------------------------------------
# 0. STYLE CSS POUR BORDURE DE CHAQUE CELLULE
# ------------------------------------------
style_freqtab <- htmltools::tags$style(HTML("
table.freqtab {
border-collapse: collapse;
width: 100%;
}
table.freqtab th, table.freqtab td {
border: 1px solid #bfbfbf;
padding: 4px 6px;
}
"))
# ------------------------------------------------
# 1. TABLES DE FRÉQUENCE EN DATA.FRAME
# ------------------------------------------------
freq_quartiers <- table(annonces$Quartiers)
freq_energie   <- table(annonces$label_eco)
freq_pieces    <- table(annonces$Pièces)
freq_loyer_grp <- table(annonces$Loyer_Groupe)
# ------------------------------------------------
# 2. FONCTION : CRÉER UNE TABLE COLORÉE & BORDÉE
# ------------------------------------------------
make_table <- function(tab, title, colname){
df <- as.data.frame(tab)
names(df) <- c(colname, "Freq")  # renomme Var1
kable(
df,
format      = "html",
caption     = paste0("<b>", title, "</b>"),
align       = "c",
escape      = FALSE,
table.attr  = 'class="freqtab"'
) %>%
kable_styling(
bootstrap_options = c("striped", "hover", "condensed"),
full_width        = FALSE,
font_size         = 12
) %>%
as.character()
}
# ------------------------------------------------
# 3. TABLES INDIVIDUELLES AVEC NOM DE COLONNE
# ------------------------------------------------
t1 <- make_table(freq_quartiers, "Quartiers",          "Quartier")
t2 <- make_table(freq_energie,   "Classe énergétique", "Classe")
t3 <- make_table(freq_pieces,    "Nombre de pièces",   "Pièces")
t4 <- make_table(freq_loyer_grp, "Groupes de loyers",  "Groupe")
# ------------------------------------------------
# 4. AFFICHAGE HORIZONTAL AVEC CADRES COLORÉS
# ------------------------------------------------
htmltools::tagList(
style_freqtab,   # Injection du style CSS
htmltools::div(
style = "display:flex; gap:20px; justify-content:space-between;",
# --- Tableau 1 : Bleu ---
htmltools::div(
style="flex:1; border:3px solid #1f77b4; border-radius:8px; padding:10px; background-color:#e8f1fb;",
HTML(t1)
),
# --- Tableau 2 : Vert ---
htmltools::div(
style="flex:1; border:3px solid #2ca02c; border-radius:8px; padding:10px; background-color:#e8f9ec;",
HTML(t2)
),
# --- Tableau 3 : Orange ---
htmltools::div(
style="flex:1; border:3px solid #ff7f0e; border-radius:8px; padding:10px; background-color:#fff3e6;",
HTML(t3)
),
# --- Tableau 4 : Rouge ---
htmltools::div(
style="flex:1; border:3px solid #d62728; border-radius:8px; padding:10px; background-color:#fde8ea;",
HTML(t4)
)
)
)
library(ggplot2)
library(gridExtra)
#On peut aussi regarder les boxplots pour chaque variable pour avoir une idée rapide des quartiles.
graphConso.bp <- function(uneVariable){
ggplot(data = annonces, aes_string(x = "factor(0)", y = uneVariable)) +
geom_boxplot() + xlab("")
}
p1.bp <- graphConso.bp("Surface")
p2.bp <- graphConso.bp("Charges")
p3.bp <- graphConso.bp("Pièces")
p4.bp <- graphConso.bp("label_eco")
p5.bp <- graphConso.bp("kWh")
p6.bp <- graphConso.bp("kgCO2")
grid.arrange(p1.bp, p2.bp, p3.bp, p4.bp, p5.bp, p6.bp, ncol = 2)
selon_quartier <-ggplot(annonces, aes(x = Quartiers, y = Loyer_TTC)) +
geom_boxplot(fill = "orange", color = "black") +
labs(
title = "Distribution du prix du loyer selon quartiers",
x = "Nom de quartiers ",
y = "Loyer TCC (euros)"
) +
theme_minimal()
selon_nbpcs <-ggplot(annonces, aes(x = factor(Pièces), y = Loyer_TTC)) +
geom_boxplot(fill = "lightgreen", color = "black") +
labs(
title = "Distribution du prix du loyer selon le nombre de pièces",
x = "Nombre de pièces",
y = "Loyer TCC (euros)"
) +
theme_minimal()
selon_label <-ggplot(annonces, aes(x = factor(label_eco), y = Loyer_TTC)) +
geom_boxplot(fill = "lightgreen", color = "black") +
labs(
title = "Distribution du prix du loyer selon le nombre de pièces",
x = "Classe d'énergitique",
y = "Loyer TCC (euros)"
) +
theme_minimal()
grid.arrange(selon_quartier , selon_label , selon_nbpcs, ncol = 2)
library(corrplot)
vars_quanti <- annonces %>% select(-c(Quartiers , Loyer_Groupe))
corrplot(cor(vars_quanti), method="circle")
corrplot(cor(vars_quanti), method="number")
reg_simple <- lm(Loyer_TTC ~ Surface + Charges + Pièces + label_eco + kWh + kgCO2 + Centre + Nord_Est + Nord_Ouest + Ouest , data = annonces)
library(MASS)
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
# estimation du modèle complet
full.model <- lm(Loyer_TTC ~., data = annonces_regression)
# Backward regression model
step.model_backward <- stepAIC(full.model, direction = "backward",
trace = FALSE)
summary(step.model_backward)
# forward regression model
step.model_forward <- stepAIC(full.model, direction = "forward",
trace = FALSE)
summary(step.model_forward)
# Stepwise regression model
step.model_both <- stepAIC(full.model, direction = "both",
trace = FALSE)
summary(step.model_both)
install.packages("stargazer")
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces)
M_complet <- lm(Loyer_TTC ~ Surface + Charges + Pièces + label_eco + kWh + kgCO2 + Centre + Nord_Est + Nord_Ouest + Ouest , data = annonces)
install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3,M_complet,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
install.packages("stargazer")
install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M4 <- lm(Loyer_TTC ~ Surface + Charges + Charges**2 , data=annonces_regression)
M5 <- lm(log(Loyer_TTC) ~ Surface + Charges,data=annonces)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3,M4,M5,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
install.packages("stargazer")
#install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M4 <- lm(Loyer_TTC ~ Surface + Charges + Charges**2 , data=annonces_regression)
M5 <- lm(log(Loyer_TTC) ~ Surface + Charges,data=annonces)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M4,M5,M_complet   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
#install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M4 <- lm(Loyer_TTC ~ Surface + Charges + Charges**2 , data=annonces_regression)
M5 <- lm(log(Loyer_TTC) ~ Surface + Charges,data=annonces)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M4,M5,M_complet,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
library(MASS)
# estimation du modèle complet
full.model <- lm(Loyer_TTC ~., data = annonces_regression)
# Backward regression model
step.model_backward <- stepAIC(full.model, direction = "backward",
trace = FALSE)
summary(step.model_backward)
# forward regression model
step.model_forward <- stepAIC(full.model, direction = "forward",
trace = FALSE)
summary(step.model_forward)
# Stepwise regression model
step.model_both <- stepAIC(full.model, direction = "both",
trace = FALSE)
summary(step.model_both)
#install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M4 <- lm(Loyer_TTC ~ Surface + Charges + Charges**2 , data=annonces_regression)
M5 <- lm(log(Loyer_TTC) ~ Surface + Charges,data=annonces)
M6 <- lm(Loyer_TTC ~ Surface + Charges + kWh ,data=annonces_regression)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3 ,  title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M4,M5 ,M6,M_complet,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
#install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M4 <- lm(Loyer_TTC ~ Surface + Charges + Charges**2 , data=annonces_regression)
M5 <- lm(log(Loyer_TTC) ~ Surface + Charges,data=annonces)
M6 <- lm(Loyer_TTC ~ Surface + Charges + kWh ,data=annonces_regression)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3 ,  title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M4,M5 ,M6,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M_complet,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
#install.packages("stargazer")
annonces_regression <-dplyr::select(annonces, -c(Quartiers , Loyer_Groupe))
library(stargazer)
M1 <- lm(Loyer_TTC ~ Surface + Charges , data = annonces_regression)
M2 <- lm(Loyer_TTC ~ Surface  + Pièces , data = annonces_regression)
M3 <- lm(Loyer_TTC ~ Surface + Charges + Pièces , data = annonces_regression)
M4 <- lm(Loyer_TTC ~ Surface + Charges + Charges**2 , data=annonces_regression)
M5 <- lm(log(Loyer_TTC) ~ Surface + Charges,data=annonces)
M6 <- lm(Loyer_TTC ~ Surface + Charges + kWh ,data=annonces_regression)
M7 <-lm(Loyer_TTC ~ Surface + Charges + kWh + kWh**2 ,data=annonces_regression)
M8 <- lm(Loyer_TTC ~ Surface + Charges + kWh + Quartiers_Centre  ,data=annonces_regression)
M_complet <- lm(Loyer_TTC ~ . , data = annonces_regression)
stargazer(M1,M2,M3 ,  title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M4,M5 ,M6,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
stargazer(M7,M8,M_complet,   title="Modèles de régression linéaire",align=TRUE, type="text", digits=3)
# estimation du modèle complet
full.model <- lm(Loyer_TTC ~  Surface +Charges + Charges**2 + Pièces + label_eco + label_eco**2+
kWh +kWh**2 + kgCO2 + kgCO2**2 + Quartiers_Centre + `Quartiers_Nord-Est` + `Quartiers_Nord-Ouest` +
Quartiers_Ouest , data = annonces_regression)
# Backward regression model
step.model_backward <- stepAIC(full.model, direction = "backward",
trace = FALSE)
summary(step.model_backward)
# forward regression model
step.model_forward <- stepAIC(full.model, direction = "forward",
trace = FALSE)
summary(step.model_forward)
# Stepwise regression model
step.model_both <- stepAIC(full.model, direction = "both",
trace = FALSE)
summary(step.model_both)
# estimation du modèle complet
full.model <- lm(Loyer_TTC ~  Surface +Charges + Charges**2 + Pièces + label_eco + label_eco**2+
kWh +kWh**2 + kgCO2 + kgCO2**2 , data = annonces_regression)
# Backward regression model
step.model_backward <- stepAIC(full.model, direction = "backward",
trace = FALSE)
summary(step.model_backward)
# forward regression model
step.model_forward <- stepAIC(full.model, direction = "forward",
trace = FALSE)
summary(step.model_forward)
# Stepwise regression model
step.model_both <- stepAIC(full.model, direction = "both",
trace = FALSE)
summary(step.model_both)
